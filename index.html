<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Battle Diary: Editable History</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/lucide@latest"></script>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <style>
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.3s ease-out forwards; }
        .card-count-badge { text-shadow: 0px 1px 2px rgba(0,0,0,0.8); box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .card-stack-item { transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .card-stack-item:hover { transform: scale(1.15) translateY(-10px); z-index: 100; box-shadow: 0 10px 25px rgba(0,0,0,0.5); border-radius: 0.5rem; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 font-sans pb-40">
    <div id="root"></div>

    <script type="text/babel" src="./modal/ShareModal.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const ShareModal = window.ShareModal;
        const Icon = window.Icon; 

        // --- RenameModal (インライン定義) ---
        const RenameModal = ({ currentName, onClose, onSave }) => {
            const [value, setValue] = useState(currentName);

            useEffect(() => {
                setValue(currentName);
            }, [currentName]);

            const handleSave = () => {
                onSave(value);
            };

            return (
                <div className="fixed inset-0 bg-black/60 z-[110] flex items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm overflow-hidden animate-fade-in">
                        <div className="p-4 border-b bg-slate-50">
                            <h3 className="font-bold text-slate-700 flex items-center gap-2">
                                {Icon && <Icon name="pencil" size={16}/>} デッキ名の変更
                            </h3>
                        </div>
                        <div className="p-6">
                            <p className="text-xs text-slate-500 mb-2 font-bold uppercase">New Deck Name</p>
                            <input 
                                type="text" 
                                className="w-full border border-slate-300 rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" 
                                value={value}
                                onChange={(e) => setValue(e.target.value)}
                                placeholder="新しい名前を入力..."
                                autoFocus
                            />
                        </div>
                        <div className="p-4 border-t bg-slate-50 flex justify-end gap-2">
                            <button onClick={onClose} className="px-4 py-2 text-sm text-slate-600 hover:bg-slate-200 rounded transition font-bold">キャンセル</button>
                            <button onClick={handleSave} className="px-4 py-2 text-sm bg-blue-600 text-white font-bold rounded hover:bg-blue-700 transition shadow-sm">変更を保存</button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Constants ---
        const MTG_FORMATS = [
            "Standard", "Pioneer", "Modern", "Legacy", "Vintage", "Pauper", "Commander", "Limited", "Other"
        ];
        
        const STORAGE_KEY_RECORDS = 'mtg_records_v10';
        const STORAGE_KEY_DECKS = 'mtg_decks_v10';

        // --- Helper: Utilities ---
        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

        const parseDeckListForDiff = (text) => {
            if (!text) return {};
            const lines = text.split('\n');
            const deck = {};
            lines.forEach(line => {
                const match = line.trim().match(/^(\d+)\s+(.+)$/);
                if (match) {
                    let name = match[2].trim().replace(/\s*\(.*?\)\s*\d+$/, ""); 
                    deck[name] = (deck[name] || 0) + parseInt(match[1], 10);
                }
            });
            return deck;
        };

        const fetchImagesSplitMainSide = async (deckListText) => {
            const lines = deckListText.split('\n').filter(l => l.trim() !== "");
            let rawCards = [];
            lines.forEach(line => {
                const match = line.trim().match(/^(\d+)\s+(.+)$/);
                if (match) {
                    let name = match[2].trim().replace(/\s*\(.*?\)\s*\d+$/, ""); 
                    let count = parseInt(match[1], 10);
                    rawCards.push({ name, count });
                }
            });

            let currentSideCount = 0;
            let sideList = [];
            let mainList = [];
            
            for (let i = rawCards.length - 1; i >= 0; i--) {
                const card = rawCards[i];
                if (currentSideCount < 15) {
                    const spaceInSide = 15 - currentSideCount;
                    if (card.count <= spaceInSide) {
                        sideList.unshift(card);
                        currentSideCount += card.count;
                    } else {
                        const toSide = spaceInSide;
                        const toMain = card.count - spaceInSide;
                        sideList.unshift({ name: card.name, count: toSide });
                        mainList.unshift({ name: card.name, count: toMain });
                        currentSideCount += toSide;
                    }
                } else {
                    mainList.unshift(card);
                }
            }

            const uniqueNames = [...new Set([...mainList, ...sideList].map(c => c.name))];
            const urlMap = {};
            
            const promises = uniqueNames.map(async (cardName) => {
                try {
                    let res = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
                    let data = null;

                    if (res.ok) {
                        data = await res.json();
                    } else {
                        const searchRes = await fetch(`https://api.scryfall.com/cards/search?q=${encodeURIComponent(cardName)}`);
                        if (searchRes.ok) {
                            const searchResult = await searchRes.json();
                            if (searchResult.data && searchResult.data.length > 0) {
                                data = searchResult.data[0];
                            }
                        }
                    }

                    if (data) {
                        urlMap[cardName] = data.image_uris?.small || data.card_faces?.[0]?.image_uris?.small;
                    } else {
                        urlMap[cardName] = null;
                    }
                } catch { 
                    urlMap[cardName] = null; 
                }
            });
            await Promise.all(promises);

            const attachUrl = (list) => list.map(c => ({ ...c, url: urlMap[c.name] })).filter(c => c.url);
            return { main: attachUrl(mainList), side: attachUrl(sideList) };
        };

        const DeckImageViewer = ({ images, title }) => {
            if (!images || images.length === 0) return null;
            return (
                <div className="mb-6">
                    <h4 className="text-[10px] font-bold text-slate-500 uppercase mb-2 border-b border-slate-300 pb-1">{title}</h4>
                    <div className="grid grid-cols-3 sm:grid-cols-6 gap-x-2 pt-24 pb-4 px-1">
                        {images.map((img, i) => (
                            <div key={i} className="relative w-full -mt-24 card-stack-item">
                                <img src={img.url} className="w-full rounded-lg shadow-md border border-slate-600 bg-slate-800 block" alt={img.name} />
                                <span className="absolute top-1 right-1 bg-black/90 text-white text-[10px] font-bold px-1.5 py-0.5 rounded border border-white/30 card-count-badge z-10">
                                    ×{img.count}
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- Data Structures ---
        const createGamesBlock = () => [
            { id: 1, result: null, onPlay: null, memo: '' },
            { id: 2, result: null, onPlay: null, memo: '' },
            { id: 3, result: null, onPlay: null, memo: '' }
        ];

        const createNewMatchBlock = (id) => ({
            id: id,
            opponentDeck: '',
            games: createGamesBlock()
        });

        // --- Main App ---
        const MtgDiaryApp = () => {
            const [view, setView] = useState('list');
            const [records, setRecords] = useState([]); 
            const [decks, setDecks] = useState({}); 
            const [showGuide, setShowGuide] = useState(false);
            const [shareRecord, setShareRecord] = useState(null);

            const [renamingDeckId, setRenamingDeckId] = useState(null);

            const initialForm = {
                date: new Date().toISOString().split('T')[0],
                location: '', 
                deckId: null, 
                deckName: '',
                format: 'Modern', 
                matches: [ createNewMatchBlock(1) ],
                deckListText: ''
            };

            const [formData, setFormData] = useState(initialForm);
            const [editingId, setEditingId] = useState(null); 
            const [parsedDeckForDiff, setParsedDeckForDiff] = useState({});
            
            const [deckImagesData, setDeckImagesData] = useState({ main: [], side: [] });
            const [deckDiff, setDeckDiff] = useState(null);
            const [isLoadingImages, setIsLoadingImages] = useState(false);
            
            const fileInputRef = useRef(null);

            useEffect(() => {
                const savedRecords = localStorage.getItem(STORAGE_KEY_RECORDS);
                const savedDecks = localStorage.getItem(STORAGE_KEY_DECKS);

                if (savedRecords && savedDecks) {
                    setRecords(JSON.parse(savedRecords));
                    setDecks(JSON.parse(savedDecks));
                } else {
                    const v9Records = JSON.parse(localStorage.getItem('mtg_records_v9') || '[]');
                    const v9Decks = JSON.parse(localStorage.getItem('mtg_decks_v9') || '{}');

                    if (v9Records.length > 0 || Object.keys(v9Decks).length > 0) {
                        const newDecks = {};
                        const nameToIdMap = {};
                        Object.keys(v9Decks).forEach(name => {
                            const newId = generateId();
                            newDecks[newId] = { id: newId, name: name, ...v9Decks[name] };
                            nameToIdMap[name] = newId;
                        });
                        const newRecords = v9Records.map(rec => ({
                            ...rec,
                            deckId: nameToIdMap[rec.deckName] || null
                        }));
                        setRecords(newRecords);
                        setDecks(newDecks);
                        localStorage.setItem(STORAGE_KEY_RECORDS, JSON.stringify(newRecords));
                        localStorage.setItem(STORAGE_KEY_DECKS, JSON.stringify(newDecks));
                    }
                }
                if (window.lucide) window.lucide.createIcons();
            }, []);

            useEffect(() => { if(window.lucide) window.lucide.createIcons(); }, [view, records, deckDiff, formData.matches.length, showGuide, shareRecord, decks, renamingDeckId]);

            const deckStats = useMemo(() => {
                const stats = {};
                Object.values(decks).forEach(deck => {
                    stats[deck.id] = { 
                        name: deck.name,
                        matchWins: 0, matchLosses: 0, matchDraws: 0, totalMatches: 0,
                        format: deck.format || 'Unknown' 
                    };
                });
                records.forEach(r => {
                    const dId = r.deckId;
                    if (dId && stats[dId]) {
                        r.matches.forEach(m => {
                            if (m.matchResult === 'win') stats[dId].matchWins++;
                            else if (m.matchResult === 'loss') stats[dId].matchLosses++;
                            else if (m.matchResult === 'draw') stats[dId].matchDraws++;
                            if (m.matchResult) stats[dId].totalMatches++;
                        });
                    }
                });
                return stats;
            }, [records, decks]);

            const saveToStorage = (newRecords, newDecks) => {
                localStorage.setItem(STORAGE_KEY_RECORDS, JSON.stringify(newRecords));
                localStorage.setItem(STORAGE_KEY_DECKS, JSON.stringify(newDecks));
            };

            const startNewEvent = (deckId = null, existingDeckData = null) => {
                setFormData({
                    ...initialForm,
                    deckId: deckId,
                    deckName: existingDeckData ? existingDeckData.name : '',
                    deckListText: existingDeckData ? existingDeckData.text : '',
                    format: existingDeckData ? (existingDeckData.format || 'Modern') : 'Modern',
                    date: new Date().toISOString().split('T')[0]
                });
                setEditingId(null);
                
                if (existingDeckData && existingDeckData.text) {
                    const parsed = parseDeckListForDiff(existingDeckData.text);
                    setParsedDeckForDiff(parsed);
                } else {
                    setParsedDeckForDiff({});
                }
                setDeckDiff(null);
                setDeckImagesData({ main: [], side: [] });
                setView('new');
            };

            const startEditEvent = (record) => {
                setFormData(JSON.parse(JSON.stringify({
                    date: record.date,
                    location: record.location,
                    deckId: record.deckId,
                    deckName: record.deckName,
                    format: record.format || 'Modern',
                    deckListText: record.deckListText,
                    matches: record.matches
                })));
                
                setEditingId(record.id); 
                setDeckDiff(record.diffSnapshot); 
                setParsedDeckForDiff(parseDeckListForDiff(record.deckListText));
                setDeckImagesData({ main: [], side: [] });
                
                setView('new');
                window.scrollTo(0, 0);
            };

            const handleDeckListChange = (text) => {
                setFormData(prev => ({ ...prev, deckListText: text }));
                if (editingId) return; 
                const currentParsed = parseDeckListForDiff(text);
                setParsedDeckForDiff(currentParsed);
                if (formData.deckId && decks[formData.deckId]) {
                    calculateDiff(decks[formData.deckId].parsed, currentParsed);
                }
            };

            const calculateDiff = (oldDeckParsed, newDeckParsed) => {
                if (!oldDeckParsed) return;
                const diff = { in: [], out: [] };
                Object.keys(newDeckParsed).forEach(card => {
                    const diffCount = newDeckParsed[card] - (oldDeckParsed[card] || 0);
                    if (diffCount > 0) diff.in.push({ name: card, count: diffCount });
                });
                Object.keys(oldDeckParsed).forEach(card => {
                    const diffCount = oldDeckParsed[card] - (newDeckParsed[card] || 0);
                    if (diffCount > 0) diff.out.push({ name: card, count: diffCount });
                });
                setDeckDiff((diff.in.length > 0 || diff.out.length > 0) ? diff : null);
            };

            const addMatch = () => {
                setFormData(prev => ({ ...prev, matches: [...prev.matches, createNewMatchBlock(prev.matches.length + 1)] }));
            };
            const updateMatchInfo = (idx, f, v) => {
                const nM = [...formData.matches]; nM[idx] = { ...nM[idx], [f]: v }; setFormData({ ...formData, matches: nM });
            };
            const updateGame = (mIdx, gIdx, f, v) => {
                const nM = [...formData.matches]; const nG = [...nM[mIdx].games]; nG[gIdx] = { ...nG[gIdx], [f]: v }; nM[mIdx].games = nG; setFormData({ ...formData, matches: nM });
            };
            const removeLastMatch = () => {
                if (formData.matches.length > 1) setFormData(prev => ({ ...prev, matches: prev.matches.slice(0, -1) }));
            };

            const handleFetchImages = async () => {
                if (!formData.deckListText) return;
                setIsLoadingImages(true);
                const imageData = await fetchImagesSplitMainSide(formData.deckListText);
                setDeckImagesData(imageData);
                setIsLoadingImages(false);
            };

            const handleDeleteRecord = () => {
                if (!editingId) return;
                if (window.confirm("本当にこの記録を削除しますか？\n（この操作は取り消せません）")) {
                    const updatedRecords = records.filter(r => r.id !== editingId);
                    setRecords(updatedRecords);
                    localStorage.setItem(STORAGE_KEY_RECORDS, JSON.stringify(updatedRecords)); 
                    setView('list');
                }
            };

            const handleSave = () => {
                if (!formData.deckName) { alert("デッキ名を入力してください"); return; }

                let eventWins = 0, eventLosses = 0, eventDraws = 0;
                const processedMatches = formData.matches.map(m => {
                    const gWins = m.games.filter(g => g.result === 'win').length;
                    const gLosses = m.games.filter(g => g.result === 'loss').length;
                    let matchResult = 'draw';
                    if (gWins > gLosses) { matchResult = 'win'; eventWins++; }
                    else if (gLosses > gWins) { matchResult = 'loss'; eventLosses++; }
                    else { eventDraws++; }
                    return { ...m, matchResult, gWins, gLosses };
                });

                const targetDeckId = formData.deckId || generateId();

                const recordData = {
                    date: formData.date,
                    location: formData.location,
                    deckId: targetDeckId,     
                    deckName: formData.deckName, 
                    format: formData.format, 
                    deckListText: formData.deckListText,
                    matches: processedMatches,
                    eventWins, eventLosses, eventDraws,
                    diffSnapshot: editingId ? deckDiff : deckDiff
                };

                let updatedRecords;
                if (editingId) {
                    updatedRecords = records.map(r => r.id === editingId ? { ...recordData, id: editingId } : r);
                } else {
                    updatedRecords = [{ ...recordData, id: Date.now() }, ...records];
                }

                const updatedDecks = { 
                    ...decks, 
                    [targetDeckId]: {
                        id: targetDeckId,
                        name: formData.deckName,
                        parsed: parsedDeckForDiff, 
                        text: formData.deckListText,
                        format: formData.format 
                    } 
                };

                setRecords(updatedRecords);
                setDecks(updatedDecks);
                saveToStorage(updatedRecords, updatedDecks);
                
                setView('list');
                setFormData(initialForm);
                setEditingId(null);
                setDeckDiff(null);
                setDeckImagesData({ main: [], side: [] });
            };

            const exportDeckHistory = (e, deckId) => {
                e.stopPropagation();
                const deckName = decks[deckId]?.name || "UnknownDeck";
                const targetRecords = records.filter(r => r.deckId === deckId);
                if (targetRecords.length === 0) {
                    alert("No records to export.");
                    return;
                }
                const dataStr = JSON.stringify(targetRecords, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `mtg_history_${deckName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const deleteDeck = (e, deckId) => {
                e.stopPropagation();
                const deckName = decks[deckId]?.name;
                if(!window.confirm(`デッキ「${deckName}」をデッキリストから削除しますか？\n(過去の対戦履歴は保持されます)`)){
                    return;
                }
                const updatedDecks = { ...decks };
                delete updatedDecks[deckId];
                setDecks(updatedDecks);
                localStorage.setItem(STORAGE_KEY_DECKS, JSON.stringify(updatedDecks));
            };

            const openRenameModal = (e, deckId) => {
                e.stopPropagation();
                setRenamingDeckId(deckId);
            };

            const handleRenameSave = (newName) => {
                if (!renamingDeckId || !decks[renamingDeckId]) return;
                
                if (!newName || !newName.trim()) {
                    alert("デッキ名を入力してください");
                    return;
                }

                const updatedDecks = { ...decks };
                updatedDecks[renamingDeckId] = { ...updatedDecks[renamingDeckId], name: newName };

                const updatedRecords = records.map(r => 
                    r.deckId === renamingDeckId ? { ...r, deckName: newName } : r
                );

                setDecks(updatedDecks);
                setRecords(updatedRecords);
                saveToStorage(updatedRecords, updatedDecks);
                
                setRenamingDeckId(null);
            };

            const triggerImport = () => { fileInputRef.current.click(); };

            const handleImportFile = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedRecords = JSON.parse(event.target.result);
                        if (!Array.isArray(importedRecords)) { alert("Invalid file format."); return; }
                        
                        let newRecords = [...records];
                        let updatedCount = 0, addedCount = 0;
                        let newDecks = { ...decks };
                        const importMapOldIdToNewId = {};

                        importedRecords.forEach(impRec => {
                            const existingIdx = newRecords.findIndex(r => r.id === impRec.id);
                            let targetDeckId = null;
                            if (impRec.deckId && importMapOldIdToNewId[impRec.deckId]) {
                                targetDeckId = importMapOldIdToNewId[impRec.deckId];
                            } else {
                                targetDeckId = generateId();
                                if (impRec.deckId) importMapOldIdToNewId[impRec.deckId] = targetDeckId;
                                
                                if (impRec.deckName && impRec.deckListText) {
                                    newDecks[targetDeckId] = {
                                        id: targetDeckId,
                                        name: impRec.deckName,
                                        text: impRec.deckListText,
                                        parsed: parseDeckListForDiff(impRec.deckListText),
                                        format: impRec.format || 'Modern'
                                    };
                                }
                            }
                            const recordToSave = { ...impRec, deckId: targetDeckId };
                            if (existingIdx > -1) { newRecords[existingIdx] = recordToSave; updatedCount++; } 
                            else { newRecords.push(recordToSave); addedCount++; }
                        });

                        newRecords.sort((a, b) => b.id - a.id);
                        setRecords(newRecords);
                        setDecks(newDecks);
                        saveToStorage(newRecords, newDecks);
                        alert(`インポート完了\n更新: ${updatedCount}件\n追加: ${addedCount}件`);
                    } catch (err) { alert("Error parsing JSON file."); console.error(err); }
                    e.target.value = ''; 
                };
                reader.readAsText(file);
            };

            return (
                <div className="max-w-3xl mx-auto min-h-screen bg-slate-100 shadow-xl overflow-hidden sm:border-x border-slate-200">
                    <header className="bg-slate-800 text-white p-4 sticky top-0 z-50 shadow-md flex justify-between items-center">
                        <h1 className="text-lg font-bold flex items-center gap-2">
                            {Icon && <Icon name="trophy" className="text-yellow-400" />}
                            MTG Battle Diary
                        </h1>
                    </header>

                    <main className="p-4 relative">
                        {view === 'list' && (
                            <div className="mb-8">
                                <div className="bg-white rounded-xl shadow-sm border border-blue-100 p-4 mb-6">
                                    <button onClick={() => setShowGuide(!showGuide)} className="w-full flex justify-between items-center text-slate-700 font-bold text-sm">
                                        <div className="flex items-center gap-2">
                                            <div className="bg-blue-100 text-blue-600 p-1.5 rounded-full">{Icon && <Icon name="help-circle" size={16}/>}</div>
                                            このアプリの使い方
                                        </div>
                                        {Icon && <Icon name={showGuide ? "chevron-up" : "chevron-down"} size={16} className="text-slate-400"/>}
                                    </button>
                                    {showGuide && (
                                        <div className="mt-3 pt-3 border-t border-slate-100 text-xs leading-relaxed text-slate-600 space-y-2 animate-fade-in">
                                            <div className="flex gap-2"><span className="font-bold text-blue-600 whitespace-nowrap">Step 1</span><p>「Start New Deck」からデッキを選択または新規作成し、イベントの記録を開始します。</p></div>
                                            <div className="flex gap-2"><span className="font-bold text-blue-600 whitespace-nowrap">Step 2</span><p>対戦相手のアーキタイプ、ゲームごとの勝敗・先手後手・メモを入力します。<br/>デッキリストを貼り付けると、画像のプレビューや前回リストとの差分(IN/OUT)が自動計算されます。</p></div>
                                            <div className="flex gap-2"><span className="font-bold text-blue-600 whitespace-nowrap">Step 3</span><p>保存すると履歴に追加されます。リスト画面ではデッキごとの戦績確認や、名前の変更、リストからの削除が可能です。</p></div>
                                        </div>
                                    )}
                                </div>

                                <h2 className="text-sm font-bold text-slate-500 uppercase mb-3 flex items-center gap-1">
                                    {Icon && <Icon name="layers" size={16} />} Start New Deck
                                </h2>
                                <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 mb-4">
                                    {Object.values(decks).map(deck => {
                                        const dId = deck.id;
                                        const dName = deck.name;
                                        const stat = deckStats[dId] || { matchWins: 0, matchLosses: 0, matchDraws: 0, totalMatches: 0, format: 'Unknown' };
                                        const winRate = stat.totalMatches > 0 ? Math.round((stat.matchWins / (stat.matchWins + stat.matchLosses)) * 100) : 0;
                                        const rateColor = winRate >= 60 ? 'text-orange-600' : winRate >= 50 ? 'text-blue-600' : 'text-slate-400';
                                        const deckFormat = deck.format || 'Modern'; 

                                        return (
                                            <div key={dId} className="relative group">
                                                <button onClick={() => startNewEvent(dId, deck)}
                                                    className="w-full h-full bg-white border border-slate-200 p-3 rounded-xl shadow-sm hover:shadow-md hover:border-blue-300 hover:bg-blue-50 transition text-left group flex flex-col justify-between min-h-[100px]">
                                                    <div>
                                                        <div className="flex items-center gap-2 mb-1">
                                                            <div className="text-[9px] uppercase font-bold text-slate-500 bg-slate-100 px-1.5 py-0.5 rounded border border-slate-200 leading-none">{deckFormat}</div>
                                                        </div>
                                                        <div className="font-bold text-slate-800 text-sm truncate group-hover:text-blue-700 pr-12">{dName}</div>
                                                    </div>
                                                    <div className="mt-2 pt-2 border-t border-slate-100 flex justify-between items-end">
                                                        <div className="text-[10px] text-slate-500 font-mono">
                                                            {stat.matchWins}W-{stat.matchLosses}L
                                                            {stat.matchDraws > 0 && `-${stat.matchDraws}D`}
                                                        </div>
                                                        <div className={`text-xs font-black ${rateColor}`}>
                                                            {isNaN(winRate) ? '-' : `${winRate}%`}
                                                        </div>
                                                    </div>
                                                </button>
                                                
                                                <div className="absolute top-2 right-2 flex gap-1 z-10">
                                                    <button onClick={(e) => openRenameModal(e, dId)} 
                                                        className="text-slate-300 hover:text-blue-600 p-1 rounded hover:bg-blue-100 transition"
                                                        title="Rename Deck">
                                                        {Icon && <Icon name="pencil" size={12} />}
                                                    </button>
                                                    <button onClick={(e) => deleteDeck(e, dId)} 
                                                        className="text-slate-300 hover:text-red-600 p-1 rounded hover:bg-red-100 transition"
                                                        title="Remove from List">
                                                        {Icon && <Icon name="trash-2" size={12} />}
                                                    </button>
                                                    <button onClick={(e) => exportDeckHistory(e, dId)} 
                                                        className="text-slate-300 hover:text-green-600 p-1 rounded hover:bg-green-100 transition"
                                                        title="Download History">
                                                        {Icon && <Icon name="download" size={12} />}
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })}
                                    <button onClick={() => startNewEvent()}
                                        className="bg-slate-200 border border-slate-300 border-dashed p-3 rounded-xl shadow-inner hover:bg-white hover:border-orange-400 hover:text-orange-600 transition flex flex-col items-center justify-center gap-1 text-slate-500 min-h-[100px]">
                                        {Icon && <Icon name="plus" size={24} />}
                                        <span className="text-xs font-bold">New Deck</span>
                                    </button>
                                </div>
                                
                                <div className="flex justify-end mt-2">
                                    <input type="file" ref={fileInputRef} onChange={handleImportFile} className="hidden" accept=".json" />
                                    <button onClick={triggerImport} className="text-xs font-bold text-slate-400 hover:text-slate-600 flex items-center gap-1">
                                        {Icon && <Icon name="upload" size={12} />} 履歴データの取り込み (JSON)
                                    </button>
                                </div>
                            </div>
                        )}

                        {view === 'new' && (
                            <div className="bg-white rounded-xl shadow-lg p-5 animate-fade-in space-y-6">
                                <div className="flex justify-between items-center">
                                    <button onClick={() => setView('list')} className="text-slate-500 text-sm flex items-center gap-1 hover:text-slate-800">
                                        {Icon && <Icon name="arrow-left" size={16} />} キャンセル
                                    </button>
                                    <h2 className="text-slate-800 font-bold flex items-center gap-2">
                                        {Icon && <Icon name={editingId ? "edit" : "file-edit"} size={18} />} 
                                        {editingId ? "記録を編集" : "イベント記録"}
                                    </h2>
                                </div>
                                
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 bg-slate-50 p-4 rounded-lg border border-slate-200">
                                    <div className="flex gap-2">
                                        <div className="w-1/3">
                                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Date</label>
                                            <input type="date" className="w-full bg-white border rounded p-2 text-sm"
                                                value={formData.date} onChange={(e) => setFormData({...formData, date: e.target.value})} />
                                        </div>
                                        <div className="w-2/3">
                                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Location</label>
                                            <input type="text" className="w-full bg-white border rounded p-2 text-sm" placeholder="場所..."
                                                value={formData.location} onChange={(e) => setFormData({...formData, location: e.target.value})} />
                                        </div>
                                    </div>
                                    <div className="flex gap-2">
                                        <div className="w-1/3">
                                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">Format</label>
                                            <select className="w-full bg-white border rounded p-2 text-sm appearance-none"
                                                value={formData.format} onChange={(e) => setFormData({...formData, format: e.target.value})}>
                                                {MTG_FORMATS.map(fmt => <option key={fmt} value={fmt}>{fmt}</option>)}
                                            </select>
                                        </div>
                                        <div className="w-2/3">
                                            <label className="block text-[10px] font-bold text-slate-500 uppercase mb-1">My Deck</label>
                                            <input type="text" className="w-full bg-white border rounded p-2 text-sm font-bold text-slate-700" placeholder="デッキ名"
                                                value={formData.deckName} onChange={(e) => setFormData({...formData, deckName: e.target.value})} />
                                        </div>
                                    </div>
                                </div>

                                <div className="space-y-6">
                                    {formData.matches.map((match, mIdx) => (
                                        <div key={match.id} className="border border-slate-300 rounded-xl overflow-hidden shadow-sm relative animate-fade-in bg-white">
                                            <div className="bg-slate-100 p-3 border-b border-slate-200 flex flex-wrap gap-3 items-center justify-between">
                                                <div className="flex items-center gap-3 w-full sm:w-auto">
                                                    <span className="bg-slate-800 text-white text-xs font-bold px-2 py-1 rounded">R{match.id}</span>
                                                    <input type="text" placeholder="対戦相手のデッキ"
                                                        className="bg-white border border-slate-300 rounded px-2 py-1 text-sm flex-1 sm:w-64 focus:ring-1 focus:ring-blue-500 outline-none"
                                                        value={match.opponentDeck} onChange={(e) => updateMatchInfo(mIdx, 'opponentDeck', e.target.value)} />
                                                </div>
                                            </div>
                                            <div className="divide-y divide-slate-100">
                                                {match.games.map((game, gIdx) => (
                                                    <div key={game.id} className="p-3 flex flex-col sm:flex-row gap-3 items-start sm:items-center">
                                                        <div className="flex items-center flex-wrap gap-3 min-w-[240px]">
                                                            <span className="text-xs font-bold text-slate-400 w-8">G{game.id}</span>
                                                            <div className="flex bg-slate-100 rounded p-0.5 border border-slate-200">
                                                                <button onClick={() => updateGame(mIdx, gIdx, 'onPlay', true)} className={`px-2 py-1 text-[10px] font-bold rounded transition ${game.onPlay === true ? 'bg-orange-500 text-white' : 'text-slate-400 hover:text-slate-600'}`}>先</button>
                                                                <button onClick={() => updateGame(mIdx, gIdx, 'onPlay', false)} className={`px-2 py-1 text-[10px] font-bold rounded transition ${game.onPlay === false ? 'bg-slate-600 text-white' : 'text-slate-400 hover:text-slate-600'}`}>後</button>
                                                            </div>
                                                            <div className="flex bg-slate-100 rounded p-0.5 border border-slate-200">
                                                                {['win', 'loss', 'draw'].map(res => (
                                                                    <button key={res} onClick={() => updateGame(mIdx, gIdx, 'result', game.result === res ? null : res)}
                                                                        className={`w-8 h-6 rounded text-[10px] font-bold uppercase transition flex items-center justify-center ${
                                                                            game.result === res ? (res === 'win' ? 'bg-blue-600 text-white' : res === 'loss' ? 'bg-red-600 text-white' : 'bg-slate-500 text-white') : 'text-slate-400 hover:bg-slate-200'
                                                                        }`}>{res === 'win' ? 'W' : res === 'loss' ? 'L' : 'D'}</button>
                                                                ))}
                                                            </div>
                                                        </div>
                                                        <input type="text" className="flex-1 w-full bg-transparent border-b border-transparent hover:border-slate-200 focus:border-blue-400 outline-none text-xs py-1"
                                                            placeholder="メモ..." maxLength={100} value={game.memo} onChange={(e) => updateGame(mIdx, gIdx, 'memo', e.target.value)} />
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                    <div className="flex gap-2">
                                        <button onClick={addMatch} className="flex-1 py-3 bg-white border-2 border-dashed border-slate-300 rounded-xl text-slate-500 font-bold hover:bg-blue-50 hover:text-blue-600 transition flex justify-center items-center gap-2">
                                            {Icon && <Icon name="plus-circle" />} 次のラウンドを追加
                                        </button>
                                        {formData.matches.length > 1 && (
                                            <button onClick={removeLastMatch} className="px-4 bg-white border-2 border-dashed border-slate-300 rounded-xl text-red-400 hover:bg-red-50 hover:text-red-600 transition">
                                                {Icon && <Icon name="trash-2" />}
                                            </button>
                                        )}
                                    </div>
                                </div>

                                <div className="space-y-2 pt-6 border-t mt-8">
                                    <div className="flex justify-between items-center">
                                        <label className="text-xs font-bold text-slate-500 uppercase">Decklist & Diff</label>
                                        <button onClick={handleFetchImages} disabled={!formData.deckListText} className="text-xs text-indigo-600 font-bold hover:underline flex items-center gap-1 disabled:opacity-50">
                                            {Icon && <Icon name="image" size={12} />} View Images
                                        </button>
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <textarea className="w-full h-24 bg-slate-900 text-green-400 text-xs font-mono p-2 rounded focus:outline-none"
                                            value={formData.deckListText} onChange={(e) => handleDeckListChange(e.target.value)} 
                                            placeholder={`例:
Deck
4 Monastery Swiftspear
4 Soul-Scar Mage
...
18 Mountain

Sideboard
3 Rending Volley
...
(日本語名やArenaエクスポート形式に対応)`}
                                        />
                                        <div className="h-24 overflow-y-auto border rounded p-2 text-xs bg-white">
                                            {deckDiff ? (
                                                <div className="space-y-1">
                                                    {deckDiff.in.map((c, i) => <div key={i} className="text-green-600 flex items-center gap-1">{Icon && <Icon name="plus" size={10}/>} {c.count} {c.name}</div>)}
                                                    {deckDiff.out.map((c, i) => <div key={i} className="text-red-500 flex items-center gap-1">{Icon && <Icon name="minus" size={10}/>} {c.count} {c.name}</div>)}
                                                </div>
                                            ) : <div className="text-slate-300 italic text-center mt-8">
                                                {editingId ? "編集中のため差分計算無効" : "変更なし / 新規"}
                                            </div>}
                                        </div>
                                    </div>
                                    
                                    {isLoadingImages && <div className="text-xs text-slate-400 text-center py-2">Loading images...</div>}
                                    {(deckImagesData.main.length > 0 || deckImagesData.side.length > 0) && (
                                        <div className="bg-slate-100 p-2 rounded border border-slate-200 mt-2">
                                            <DeckImageViewer images={deckImagesData.main} title="Mainboard" />
                                            <DeckImageViewer images={deckImagesData.side} title="Sideboard" />
                                        </div>
                                    )}
                                </div>

                                <button onClick={handleSave} className="w-full bg-slate-800 text-white py-4 rounded-xl font-bold hover:bg-slate-700 transition flex justify-center items-center gap-2 shadow-xl text-lg">
                                    {Icon && <Icon name={editingId ? "refresh-cw" : "save"} />} {editingId ? "記録を更新" : "記録を保存"}
                                </button>
                                
                                {editingId && (
                                    <button onClick={handleDeleteRecord} className="w-full mt-2 text-red-500 text-xs font-bold hover:text-red-700 py-2 border border-transparent hover:border-red-100 rounded transition">
                                        この記録を削除する
                                    </button>
                                )}
                            </div>
                        )}

                        {view === 'list' && (
                            <div className="space-y-6">
                                <h2 className="text-sm font-bold text-slate-500 uppercase border-t pt-6 mb-3 flex items-center gap-1">
                                    {Icon && <Icon name="history" size={16} />} History
                                </h2>
                                {records.length === 0 && <div className="text-center py-12 text-slate-400 bg-white rounded-xl shadow border border-dashed border-slate-300"><p>記録なし</p></div>}
                                {records.map((record) => (
                                    <EventCard 
                                        key={record.id} 
                                        record={record} 
                                        onEdit={() => startEditEvent(record)}
                                        onShare={() => setShareRecord(record)} 
                                    />
                                ))}
                            </div>
                        )}
                        
                        {shareRecord && ShareModal && (
                            <ShareModal 
                                record={shareRecord} 
                                onClose={() => setShareRecord(null)} 
                            />
                        )}

                        {/* Rename Modal */}
                        {renamingDeckId && (
                            <RenameModal
                                currentName={decks[renamingDeckId]?.name || ""}
                                onClose={() => setRenamingDeckId(null)}
                                onSave={handleRenameSave}
                            />
                        )}
                    </main>
                </div>
            );
        };

        const EventCard = ({ record, onEdit, onShare }) => { 
            const [expanded, setExpanded] = useState(false);
            const [showDeckImages, setShowDeckImages] = useState(false);
            const [imagesData, setImagesData] = useState({ main: [], side: [] });
            const [loading, setLoading] = useState(false);
            
            const scoreColor = record.eventWins > record.eventLosses ? 'text-blue-600 bg-blue-50 border-blue-100' : 
                               record.eventLosses > record.eventWins ? 'text-red-600 bg-red-50 border-red-100' : 'text-slate-600 bg-slate-100';

            const toggleDeckImages = async (e) => {
                e.stopPropagation();
                if (showDeckImages) { setShowDeckImages(false); return; }
                setShowDeckImages(true);
                if (imagesData.main.length === 0 && record.deckListText) {
                    setLoading(true);
                    const fetched = await fetchImagesSplitMainSide(record.deckListText);
                    setImagesData(fetched);
                    setLoading(false);
                }
            };

            const copyDeckList = (e) => {
                e.stopPropagation();
                if (record.deckListText) navigator.clipboard.writeText(record.deckListText).then(() => alert("Copied!"));
            };

            return (
                <div className="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden hover:shadow-md transition relative">
                    <div className="p-4 cursor-pointer bg-gradient-to-r from-white to-slate-50 hover:bg-slate-50 transition" onClick={() => setExpanded(!expanded)}>
                        <div className="flex justify-between items-start">
                            <div className="pr-4">
                                <div className="flex flex-wrap gap-2 text-xs text-slate-500 font-bold mb-1 items-center">
                                    <span className="flex items-center gap-1">{Icon && <Icon name="calendar" size={12}/>} {record.date}</span>
                                    <span className="bg-slate-200 text-slate-600 px-2 py-0.5 rounded text-[10px] font-bold uppercase">{record.format || 'MODERN'}</span>
                                    {record.location && <span className="flex items-center gap-1 bg-white border px-1.5 rounded">{Icon && <Icon name="map-pin" size={12}/>} {record.location}</span>}
                                </div>
                                <h3 className="font-bold text-lg text-slate-800 break-words">{record.deckName}</h3>
                                {record.diffSnapshot && (
                                    <div className="text-[10px] mt-1 flex flex-wrap gap-2">
                                        {record.diffSnapshot.in.length > 0 && <span className="text-green-600 flex items-center gap-1">In: {record.diffSnapshot.in.map(c => `${c.count} ${c.name}`).join(", ")}</span>}
                                        {record.diffSnapshot.out.length > 0 && <span className="text-red-500 flex items-center gap-1">Out: {record.diffSnapshot.out.map(c => `${c.count} ${c.name}`).join(", ")}</span>}
                                    </div>
                                )}
                            </div>
                            
                            <div className="flex flex-col items-end gap-3 shrink-0">
                                <div className="flex gap-2">
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); onShare(); }}
                                        className="text-slate-400 hover:text-blue-500 transition p-1.5 rounded-full hover:bg-blue-50 border border-transparent hover:border-blue-100"
                                        title="Share Result"
                                    >
                                        {Icon && <Icon name="share-2" size={16} />}
                                    </button>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); onEdit(); }}
                                        className="text-slate-400 hover:text-blue-500 transition p-1.5 rounded-full hover:bg-blue-50 border border-transparent hover:border-blue-100"
                                        title="Edit Record"
                                    >
                                        {Icon && <Icon name="pencil" size={16} />}
                                    </button>
                                </div>
                                <div className={`text-xl font-black px-3 py-1 rounded border ${scoreColor}`}>
                                    {record.eventWins}-{record.eventLosses}
                                </div>
                            </div>
                        </div>
                    </div>

                    {expanded && (
                        <div className="border-t border-slate-100 animate-fade-in">
                            <div className="bg-slate-50/50 p-2 space-y-2">
                                {record.matches.map((match) => (
                                    <div key={match.id} className="bg-white border border-slate-200 rounded-lg p-3 shadow-sm">
                                        <div className="flex justify-between items-center mb-2 pb-1 border-b border-slate-100">
                                            <div className="flex items-center gap-2">
                                                <span className="text-xs font-bold bg-slate-800 text-white px-1.5 py-0.5 rounded">R{match.id}</span>
                                                <span className="text-sm font-bold text-slate-700">{match.opponentDeck || "Unknown"}</span>
                                            </div>
                                            <span className={`text-xs font-bold uppercase ${match.matchResult === 'win' ? 'text-blue-600' : match.matchResult === 'loss' ? 'text-red-600' : 'text-slate-400'}`}>
                                                {match.matchResult}
                                            </span>
                                        </div>
                                        <div className="space-y-1">
                                            {match.games.map((g) => {
                                                if (!g.result && !g.memo && g.onPlay === null) return null;
                                                return (
                                                    <div key={g.id} className="flex gap-2 text-xs items-center">
                                                        {g.onPlay !== null && <span className={`px-1 rounded text-[9px] font-bold ${g.onPlay ? 'bg-orange-100 text-orange-700' : 'bg-slate-200 text-slate-600'}`}>{g.onPlay ? '先' : '後'}</span>}
                                                        <span className={`font-mono font-bold w-4 text-center ${g.result === 'win' ? 'text-blue-600' : g.result === 'loss' ? 'text-red-600' : 'text-slate-300'}`}>{g.result === 'win' ? 'W' : g.result === 'loss' ? 'L' : '-'}</span>
                                                        <span className="text-slate-600 flex-1">{g.memo}</span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="bg-slate-100 p-2 border-t border-slate-200">
                                <div className="flex gap-2">
                                    <button onClick={toggleDeckImages} className="flex-1 text-xs font-bold text-slate-600 bg-white border hover:bg-slate-50 py-2 rounded flex justify-center items-center gap-1 transition">
                                        {Icon && <Icon name={showDeckImages ? "chevron-up" : "image"} size={14} />} {showDeckImages ? "Hide Images" : "View Images"}
                                    </button>
                                    {showDeckImages && <button onClick={copyDeckList} className="px-4 text-xs font-bold text-indigo-600 bg-indigo-50 border border-indigo-100 hover:bg-indigo-100 py-2 rounded flex justify-center items-center gap-1 transition">{Icon && <Icon name="copy" size={14} />} Copy Text</button>}
                                </div>
                                {showDeckImages && (
                                    <div className="mt-2 p-2 bg-slate-200 rounded inner-shadow min-h-[100px]">
                                        {loading && <div className="text-center text-xs text-slate-500 py-4">Loading cards...</div>}
                                        {!loading && (
                                            <div>
                                                <DeckImageViewer images={imagesData.main} title="Mainboard" />
                                                <DeckImageViewer images={imagesData.side} title="Sideboard" />
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MtgDiaryApp />);
    </script>
</body>
</html>
